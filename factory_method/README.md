## [目的]
FactoryMethod は**インスタンスの生成**に関するパターンです。
このパターンの目的は、ポリモーフィズムにおける**インスタンス生成の局面を隠蔽**することで、**疎結合の完成度を向上**させることです。

## [構成図]

## [概要]
### 前提：ポリモーフィズムの価値
前提となるポリモーフィズム（サブタイプ多層）によるインターフェイス設計のコツは**仕事を決めてやり方を決めないこと**です。

具体的には、インターフェイスが仕事を決め、実現するクラスがやり方を決めます。 インターフェイスはそれを満足させられる任意のクラスで実現できますので、（仕事の）やり方が違う様々なクラスを適用すれば、多様な手法で仕事を全うすることができます。

また、利用側にはインターフェイスしか見せませんので、実現されたクラスが変わったとしても**利用側の修正や再テストは不要**です。これは **疎結合**を実現する基本要素であり、また利用側が（設計の甘い実実装ではなく）十分に仕様を疎にしたインターフェイスに依存しているという状態は、**開放閉鎖原則**の閉鎖部分「修正に対して閉じられていなければならない」を実現する一助となります。

### 課題：ポリモーフィズム実現の隙
しかし、インターフェイスを利用するには**構造体を生成**しインターフェイスに代入しなければなりません。
この生成・代入の瞬間を利用側のクラスが知ってしまうと、疎結合が崩れ、クラスの修正や再テストが必要になってしまいます。

具体例として、以下のコードでは具象側の構造体の実名が出ていますので、完全な疎結合にはなりません。
利用側のコードに`Vehicle`の実体が `Car`と見えてしまっているので、実装を入れ替えるには利用側の再コンパイル（修正）が必要です。
```go
// Vehicle: インターフェイス, Car: 構造体
var v Vehicle = &Car{}
```

### 解決：生成過程の隠蔽化
そこで、利用側のクラスは FactoryMethodにこの仕事を依頼します。 そうすることで、利用側は実現するクラスに対して何も知らずに済み、疎結合が完成し、保守効率も上がります。
つまり、Factoryの第一の目的は「工場という閉鎖空間を使って、何を生成しているかを隠蔽する」という闇深いことなのです。

```go
// Vehicle: インターフェイス, Car: 構造体（隠蔽されている）
var v Vehicle = VehicleFactory.New()
```

## [実例・類似例]
- DIコンテナは Factoryの完成形と言えるべきものです。単純な隠蔽だけでなく、関連を完成させ、Factory自体も見せないといった付加価値まで提供しています。
- Singletonの getInstance() はインスタンスの実体ではなくインスタンスの生成を隠蔽しています。目的は異なりますが作りは似ています。